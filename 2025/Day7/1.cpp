// 7: Laboratories ---
//
// You thank the cephalopods for the help and exit the trash compactor, finding
// yourself in the familiar halls of a North Pole research wing.
//
// Based on the large sign that says "teleporter hub", they seem to be
// researching teleportation; you can't help but try it for yourself and step
// onto the large yellow teleporter pad.
//
// Suddenly, you find yourself in an unfamiliar room! The room has no doors; the
// only way out is the teleporter. Unfortunately, the teleporter seems to be
// leaking magic smoke.
//
// Since this is a teleporter lab, there are lots of spare parts, manuals, and
// diagnostic equipment lying around. After connecting one of the diagnostic
// tools, it helpfully displays error code 0H-N0, which apparently means that
// there's an issue with one of the tachyon manifolds.
//
// You quickly locate a diagram of the tachyon manifold (your puzzle input). A
// tachyon beam enters the manifold at the location marked S; tachyon beams
// always move downward. Tachyon beams pass freely through empty space (.).
// However, if a tachyon beam encounters a splitter (^), the beam is stopped;
// instead, a new tachyon beam continues from the immediate left and from the
// immediate right of the splitter.
//
// For example:
//
// .......S.......
// ...............
// .......^.......
// ...............
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............
//
// In this example, the incoming tachyon beam (|) extends downward from S until
// it reaches the first splitter:
//
// .......S.......
// .......|.......
// .......^.......
// ...............
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............
//
// At that point, the original beam stops, and two new beams are emitted from
// the splitter:
//
// .......S.......
// .......|.......
// ......|^|......
// ...............
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............
//
// Those beams continue downward until they reach more splitters:
//
// .......S.......
// .......|.......
// ......|^|......
// ......|.|......
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............
//
// At this point, the two splitters create a total of only three tachyon beams,
// since they are both dumping tachyons into the same place between them:
//
// .......S.......
// .......|.......
// ......|^|......
// ......|.|......
// .....|^|^|.....
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............
//
// This process continues until all of the tachyon beams reach a splitter or
// exit the manifold:
//
// .......S.......
// .......|.......
// ......|^|......
// ......|.|......
// .....|^|^|.....
// .....|.|.|.....
// ....|^|^|^|....
// ....|.|.|.|....
// ...|^|^|||^|...
// ...|.|.|||.|...
// ..|^|^|||^|^|..
// ..|.|.|||.|.|..
// .|^|||^||.||^|.
// .|.|||.||.||.|.
// |^|^|^|^|^|||^|
// |.|.|.|.|.|||.|
//
// To repair the teleporter, you first need to understand the beam-splitting
// properties of the tachyon manifold. In this example, a tachyon beam is split
// a total of 21 times.
//
// Analyze your manifold diagram. How many times will the beam be split?
//
#include <algorithm>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

#include <bits/stdc++.h>
using namespace std;
bool checkifDone(vector<char> a[], int nRow) {
  for (int i = 0; i < a[nRow - 1].size(); i++) {
    if (a[nRow - 1][i] == '|') {
      return true;
    }
  }
  return false;
}
void printBoard(vector<char> a[], int nRow) {
  for (int i = 0; i < nRow; i++) {
    for (int j = 0; j < a[0].size(); j++) {
      cout << a[i][j];
    }
    cout << endl;
  }
}

int main() {

  ifstream input("input.txt");
  if (!input) {
    cerr << "Unable to open file input.txt\n";
    return 1;
  }

  vector<string> grid;
  string line;
  while (getline(input, line)) {
    if (line.size() == 0) {
      break;
    }
    grid.push_back(line);
  }

  vector<char> board[150];
  int no_of_rows = 0;
  for (int i = 0; i < grid.size(); i++) {
    string current_line = grid[i];
    for (int j = 0; j < grid[i].size(); j++) {
      board[i].push_back(current_line[j]);
    }
    no_of_rows++;
  }
  printBoard(board, no_of_rows);
  // while (checkifDone(board, no_of_rows)) {
  //
  // }
  // find index of S
  int iS;
  for (int i = 0; i < board[0].size(); i++) {
    if (board[0][i] == 'S') {
      iS = i;
    }
  }
  vector<int> iTarget;
  iTarget.push_back(iS);

  vector<int> nextTargets;
  nextTargets.push_back(iS);
  int no_of_split = 0;
  for (int i = 1; i < no_of_rows; i++) {

    for (int k = 0; k < iTarget.size(); k++) {
      if (board[i][iTarget[k]] == '.') {
        board[i][iTarget[k]] = '|';
      }
      if (board[i][iTarget[k]] == '^') {
        auto newEnd =
            remove(nextTargets.begin(), nextTargets.end(), iTarget[k]);

        nextTargets.erase(newEnd, nextTargets.end());
        nextTargets.push_back(iTarget[k] + 1);
        nextTargets.push_back(iTarget[k] - 1);
        no_of_split++;
        //erase dupliate if 2 split cause only 3 beams
        sort(nextTargets.begin(), nextTargets.end());

        newEnd = std::unique(nextTargets.begin(), nextTargets.end());

        nextTargets.erase(newEnd, nextTargets.end());
      }
    }
    iTarget = nextTargets;
    printBoard(board, no_of_rows);
  }
  cout << no_of_split << " " << iTarget.size() << " " << nextTargets.size()
       << endl;
}
